<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="/resources/spdi-openaccess-jats.xsl"?>
<!DOCTYPE response [
	
<!ENTITY % article SYSTEM "http://jats.nlm.nih.gov/archiving/1.2/JATS-archivearticle1.dtd">
<!ENTITY % book-part-wrapper SYSTEM "http://jats.nlm.nih.gov/extensions/bits/2.0/BITS-book2.dtd">
	]><response><apiMessage>This XML was provided by Springer Nature</apiMessage><query>doi:10.1186/s13634-015-0192-3</query><apiKey>87ba7cb21f89ce78154df796840621f4</apiKey><result><total>1</total><start>1</start><pageLength>2</pageLength><recordsDisplayed>1</recordsDisplayed></result><records><article dtd-version="1.2" article-type="research-article" xml:lang="en" specific-use="web-only" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"><front><journal-meta><journal-id journal-id-type="publisher-id">13634</journal-id><journal-id journal-id-type="doi">10.1007/13634.1687-6180</journal-id><journal-title-group><journal-title>EURASIP Journal on Advances in Signal Processing</journal-title><abbrev-journal-title abbrev-type="publisher">EURASIP J. Adv. Signal Process. </abbrev-journal-title></journal-title-group><issn pub-type="epub">1687-6180</issn><publisher><publisher-name>Springer International Publishing</publisher-name><publisher-loc>Cham</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="publisher-id">s13634-015-0192-3</article-id><article-id pub-id-type="manuscript">192</article-id><article-id pub-id-type="doi">10.1186/s13634-015-0192-3</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group><subj-group subj-group-type="article-collection" specific-use=""><subject>Advanced signal processing techniques and telecommunications network infrastructures for Smart Grid  analysis, monitoring and management</subject></subj-group></article-categories><title-group><article-title xml:lang="en">Rapid algorithm prototyping and implementation for power quality measurement</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes"><name><surname>Kołek</surname><given-names>Krzysztof</given-names></name><address><email>kko@agh.edu.pl</email></address><xref ref-type="aff" rid="Aff1">1</xref><xref ref-type="corresp" rid="IDs1363401501923_cor1">a</xref></contrib><contrib contrib-type="author"><name><surname>Piątek</surname><given-names>Krzysztof</given-names></name><address><email>kpiatek@agh.edu.pl</email></address><xref ref-type="aff" rid="Aff1">1</xref></contrib><aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.9922.0</institution-id><institution-id institution-id-type="ISNI">0000000091741488</institution-id><institution content-type="org-name">AGH University of Science and Technology</institution></institution-wrap><addr-line content-type="street">al. A.Mickiewicza 30</addr-line><addr-line content-type="postcode">30-059</addr-line><addr-line content-type="city">Kraków</addr-line><country country="PL">Poland</country></aff></contrib-group><author-notes><corresp id="IDs1363401501923_cor1"><label>a</label><email>kko@agh.edu.pl</email></corresp></author-notes><pub-date date-type="pub" publication-format="electronic"><day>10</day><month>3</month><year>2015</year></pub-date><pub-date date-type="collection" publication-format="electronic"><month>12</month><year>2015</year></pub-date><volume>2015</volume><issue seq="17">1</issue><elocation-id>19</elocation-id><history><date date-type="registration"><day>2</day><month>1</month><year>2015</year></date><date date-type="received"><day>29</day><month>10</month><year>2014</year></date><date date-type="accepted"><day>2</day><month>1</month><year>2015</year></date><date date-type="online"><day>10</day><month>3</month><year>2015</year></date></history><permissions><copyright-statement content-type="compact">© Kołek and Piątek; licensee Springer. 2015</copyright-statement><copyright-statement content-type="comment">This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link xlink:href="http://creativecommons.org/licenses/by/4.0" ext-link-type="uri">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly credited.</copyright-statement><copyright-year>2015</copyright-year><copyright-holder>Kołek and Piątek; licensee Springer.</copyright-holder><license license-type="open-access" xlink:href="https://creativecommons.org/licenses/by/4.0"><license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link xlink:href="https://creativecommons.org/licenses/by/4.0" ext-link-type="uri">https://creativecommons.org/licenses/by/4.0</ext-link>), which permits use, duplication, adaptation, distribution, and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made.</license-p></license></permissions><abstract xml:lang="en" id="Abs1"><title>Abstract</title><p id="Par1">This article presents a Model-Based Design (MBD) approach to rapidly implement power quality (PQ) metering algorithms. Power supply quality is a very important aspect of modern power systems and will become even more important in future smart grids. In this case, maintaining the PQ parameters at the desired level will require efficient implementation methods of the metering algorithms. Currently, the development of new, advanced PQ metering algorithms requires new hardware with adequate computational capability and time intensive, cost-ineffective manual implementations. An alternative, considered here, is an MBD approach. The MBD approach focuses on the modelling and validation of the model by simulation, which is well-supported by a Computer-Aided Engineering (CAE) packages. This paper presents two algorithms utilized in modern PQ meters: a phase-locked loop based on an Enhanced Phase Locked Loop (EPLL), and the flicker measurement according to the IEC 61000-4-15 standard. The algorithms were chosen because of their complexity and non-trivial development. They were first modelled in the MATLAB/Simulink package, then tested and validated in a simulation environment. The models, in the form of Simulink diagrams, were next used to automatically generate C code. The code was compiled and executed in real-time on the Zynq Xilinx platform that combines a reconfigurable Field Programmable Gate Array (FPGA) with a dual-core processor. The MBD development of PQ algorithms, automatic code generation, and compilation form a rapid algorithm prototyping and implementation path for PQ measurements. The main advantage of this approach is the ability to focus on the design, validation, and testing stages while skipping over implementation issues. The code generation process renders production-ready code that can be easily used on the target hardware. This is especially important when standards for PQ measurement are in constant development, and the PQ issues in emerging smart grids will require tools for rapid development and implementation of such algorithms.</p></abstract><kwd-group xml:lang="en"><title>Keywords</title><kwd>Automatic code generation</kwd><kwd>Flicker</kwd><kwd>PLL</kwd><kwd>Power quality</kwd><kwd>Rapid prototyping</kwd><kwd>Simulink</kwd><kwd>Synchronisation</kwd></kwd-group><custom-meta-group><custom-meta><meta-name>publisher-imprint-name</meta-name><meta-value>Springer</meta-value></custom-meta><custom-meta><meta-name>volume-issue-count</meta-name><meta-value>1</meta-value></custom-meta><custom-meta><meta-name>issue-article-count</meta-name><meta-value>0</meta-value></custom-meta><custom-meta><meta-name>issue-toc-levels</meta-name><meta-value>0</meta-value></custom-meta><custom-meta><meta-name>issue-pricelist-year</meta-name><meta-value>2015</meta-value></custom-meta><custom-meta><meta-name>issue-copyright-holder</meta-name><meta-value>The Author(s)</meta-value></custom-meta><custom-meta><meta-name>issue-copyright-year</meta-name><meta-value>2015</meta-value></custom-meta><custom-meta><meta-name>article-contains-esm</meta-name><meta-value>No</meta-value></custom-meta><custom-meta><meta-name>article-numbering-style</meta-name><meta-value>ContentOnly</meta-value></custom-meta><custom-meta><meta-name>article-registration-date-year</meta-name><meta-value>2015</meta-value></custom-meta><custom-meta><meta-name>article-registration-date-month</meta-name><meta-value>1</meta-value></custom-meta><custom-meta><meta-name>article-registration-date-day</meta-name><meta-value>2</meta-value></custom-meta><custom-meta><meta-name>article-toc-levels</meta-name><meta-value>0</meta-value></custom-meta><custom-meta><meta-name>toc-levels</meta-name><meta-value>0</meta-value></custom-meta><custom-meta><meta-name>volume-type</meta-name><meta-value>Regular</meta-value></custom-meta><custom-meta><meta-name>journal-product</meta-name><meta-value>ArchiveJournal</meta-value></custom-meta><custom-meta><meta-name>numbering-style</meta-name><meta-value>ContentOnly</meta-value></custom-meta><custom-meta><meta-name>article-collection-editor</meta-name><meta-value>Antonio Bracale, Gary Chan, Julio Barros, Emiliano Dall'Anese, Angela Sara Cacciapuoti</meta-value></custom-meta><custom-meta><meta-name>article-grants-type</meta-name><meta-value>OpenChoice</meta-value></custom-meta><custom-meta><meta-name>metadata-grant</meta-name><meta-value>OpenAccess</meta-value></custom-meta><custom-meta><meta-name>abstract-grant</meta-name><meta-value>OpenAccess</meta-value></custom-meta><custom-meta><meta-name>bodypdf-grant</meta-name><meta-value>OpenAccess</meta-value></custom-meta><custom-meta><meta-name>bodyhtml-grant</meta-name><meta-value>OpenAccess</meta-value></custom-meta><custom-meta><meta-name>bibliography-grant</meta-name><meta-value>OpenAccess</meta-value></custom-meta><custom-meta><meta-name>esm-grant</meta-name><meta-value>OpenAccess</meta-value></custom-meta><custom-meta><meta-name>online-first</meta-name><meta-value>false</meta-value></custom-meta><custom-meta><meta-name>pdf-file-reference</meta-name><meta-value>BodyRef/PDF/13634_2015_Article_192.pdf</meta-value></custom-meta><custom-meta><meta-name>pdf-type</meta-name><meta-value>Typeset</meta-value></custom-meta><custom-meta><meta-name>target-type</meta-name><meta-value>OnlinePDF</meta-value></custom-meta><custom-meta><meta-name>issue-type</meta-name><meta-value>Regular</meta-value></custom-meta><custom-meta><meta-name>article-type</meta-name><meta-value>OriginalPaper</meta-value></custom-meta><custom-meta><meta-name>journal-subject-primary</meta-name><meta-value>Engineering</meta-value></custom-meta><custom-meta><meta-name>journal-subject-secondary</meta-name><meta-value>Signal,Image and Speech Processing</meta-value></custom-meta><custom-meta><meta-name>journal-subject-secondary</meta-name><meta-value>Quantum Information Technology, Spintronics</meta-value></custom-meta><custom-meta><meta-name>journal-subject-collection</meta-name><meta-value>Engineering</meta-value></custom-meta><custom-meta><meta-name>open-access</meta-name><meta-value>true</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1" sec-type="introduction"><title>Introduction</title><p id="Par2">Smart Grids offer an opportunity for effective power system management and utilisation of distributed and renewable energy resources. Efficient utilisation of the grid includes maintaining power supply (voltage) quality and emission (current) quality according to the specified limits. These limits can be set by the regulator, provided by standards or grid codes, or even agreed as part of an energy supply contract. The requirement of measuring the power quality (PQ) parameters has increased the interest in applications using signal processing techniques for PQ measurement. Comprehensive overviews of this problem are presented in [<xref ref-type="bibr" rid="CR1">1</xref>,<xref ref-type="bibr" rid="CR2">2</xref>]. These books describe classical methods of PQ analysis as well as the application of advanced techniques like neural networks, wavelet transform, and machine learning methods. It is clear that there is a need for increasingly complex PQ metering algorithms.</p><p id="Par3">On the other hand, PQ metering is defined by standards, e.g. EN 61000-4-30. These standards define voltage quality measurement and provide implementation details needed to build a PQ meter. Consequently, algorithms for a PQ meter include not only signal processing techniques, but also data aggregation, gapless measurement, and synchronization with line voltage waveforms or time references, etc.</p><p id="Par4">Because further requirements for PQ are constantly developing, there is a need for a rapid development platform for new algorithms. A rapid development framework should enable fast modelling, testing, and hardware implementation. The framework would be useful for preparing a reference PQ meter to test algorithms for PQ measurement or event classification in the field, prepare test procedures for upcoming certification processes, or test new ideas for PQ metering. This framework should enable rapid modelling, facilitate model validation and testing, as well as enable automatic code generation for different hardware platforms, including code generation for microprocessors and reconfigurable FPGA devices.</p><p id="Par5">The conventional V-model of software development includes specification, design, implementation, integration, testing, and verification and validation stages. This implementation process is performed manually and is time intensive. The complexity of PQ measurement algorithms and the requirement for short development cycles motivate the investigation of a more efficient, reliable, and cost-effective alternative. Model-Based Design (MBD), adapted to the development of measurement algorithms, is here considered as an option. The MBD approach to the development of measurement algorithms consists of five steps:<list list-type="order"><list-item><p id="Par6">Modelling input test signals and defining reference responses to the test inputs</p></list-item><list-item><p id="Par7">Synthesis of measurement algorithms (Computer-Aided Engineering (CAE) tools are heavily used at this stage.)</p></list-item><list-item><p id="Par8">Simulation of measurement algorithms excited by the test sequences</p></list-item><list-item><p id="Par9">Tuning the algorithms to achieve compliance of the simulated responses with reference responses</p></list-item><list-item><p id="Par10">Synthesis of the algorithms on a target hardware platform</p></list-item></list></p><p id="Par11">The MBD approach focuses on modelling and simulation, hence most of the development time is independent of target hardware. Moreover, some CAE packages automatically convert the models into a source code library, which simplifies and accelerates the synthesis stage. The automatic code generation method reduces the number of errors that appear during manual coding.</p><p id="Par12">Several attempts have been made to design rapid development methods for power systems algorithms. In [<xref ref-type="bibr" rid="CR3">3</xref>], an analysis of CAE tools such as MATLAB/Simulink and dSpace/TargetLink describes how they perform fundamental steps such as physical modelling, simulations, control algorithms design and testing, hardware evaluation, parameter optimization, and finally code generation for real-time software implementations. As an example, the development of a controller for a low power single-phase transformerless inverter was presented. The development, verification, and implementation stages of automatic code generation to implement over/under-power protection functions and MATLAB/Simulink active power filter control blocks are given in [<xref ref-type="bibr" rid="CR4">4</xref>] and [<xref ref-type="bibr" rid="CR5">5</xref>], respectively. The active power filter allows the rapid on-line tuning of the filter’s parameters, selection of control algorithms, and can be applied to generate code for microcontrollers. Kirubakaran et al. in [<xref ref-type="bibr" rid="CR6">6</xref>] presented a Digital Signal Processing (DSP) controller for a fuel-cell based system. MATLAB/Simulink was used to generate Pulse Width Modulation (PWM) signals for the TMS320F2812 DSP. The same DSP was applied to implement a unity power factor PWM rectifier and shunt active power filter, as described in [<xref ref-type="bibr" rid="CR7">7</xref>]. The automatic code generation in the MATLAB/Simulink environment for the fixed-point DSP was presented. A slightly different development path is given in [<xref ref-type="bibr" rid="CR8">8</xref>]. Simulink diagrams are automatically converted to C code, afterward converted to assembly language, and finally transferred to a DSP for execution.</p><p id="Par13">SCADA systems are considered to be the target platform for algorithms generated in Simulink. In [<xref ref-type="bibr" rid="CR9">9</xref>], a Simulink implementation of a grid load forecast algorithm was given. The Simulink diagram was applied to automatically generate OPen Connectivity (OPC) Data Access and Modbus/TCP servers. The servers were “embedded” into a SCADA for real-time load prediction.</p><p id="Par14">More specifically, PQ algorithms have been investigated. McGranaghan and Santoso in [<xref ref-type="bibr" rid="CR10">10</xref>] presented a summary of the problems encountered during both offline and online analyses of PQ algorithms. In [<xref ref-type="bibr" rid="CR11">11</xref>], a discrete model of the IEC 61000-4-15 flickermeter was presented. The full discrete flickermeter channel, developed as Simulink diagram, is shown, however the aim of this model is only simulation, and hence the implementation path is not considered. An implementation method for a Simulink algorithm that conforms the IEEE 1459-2000 standard for measurement of electric power quantities is presented in [<xref ref-type="bibr" rid="CR12">12</xref>]. The MATLAB xPC Target toolbox was used to run the code generated automatically from the Simulink diagram on a PC computer. The methods defined by the IEC 61000-4-30 standard were investigated in [<xref ref-type="bibr" rid="CR13">13</xref>]. The modelling and analysis of the algorithms were carried out in a MATLAB/Simulink environment. The algorithms were then automatically executed on a dSPACE DS 1104 board.</p><p id="Par15">In addition, studies on the compliance of automatically generated code with safety standards were performed. Krizan et al. in [<xref ref-type="bibr" rid="CR14">14</xref>] dealt with the usability of automatically generated C code in critical applications. Compliance with the DO-178C and DO-331 standards were presented. DO-178C and DO-331 address the entire software development cycle, from functional specification to software verification. The DO-178C and DO-331 are documents used by certification authorities such as the Federal Aviation Administration, European Aviation Safety Agency and Transport Canada to approve software for aerospace systems. In [<xref ref-type="bibr" rid="CR15">15</xref>], the authors used the IEC 61508 standard and investigated options for running automatically generated code on safety PLCs. Stages for code generation, evaluation, and conversion before the code was applied in safety systems were presented.</p><p id="Par16">Finally, some effort has been made to generate automatic code for reconfigurable FPGA circuits and their applications in power systems. Mekonnen et al. in [<xref ref-type="bibr" rid="CR16">16</xref>] presented the simulation of a complete full-bridge PWM converter for a solar grid-tie inverter that also provided the benefits of auto VHDL-code generation for an RMS-based digital controller. In [<xref ref-type="bibr" rid="CR17">17</xref>], a rapid prototyping platform for photovoltaic power inverters was presented. The hardware-in-the-loop approach was used to develop and validate PWM signals for different converter topologies. The control strategies are developed as Simulink diagrams, and the goal of the platform is the automatic VHDL code generation for Xilinx FPGAs.</p><p id="Par17">The scope of this paper covers the development of algorithms for PQ metering while following the MBD approach. The algorithms developed and validated first as models are then transferred to C code automatically. The MATLAB/Simulink CAE plays a central role during the development. The generated code is executed on a hardware platform and real-time processing results are compared to the measurement generated by a commercial reference device. The implementation path for two example algorithms is presented. The algorithms are chosen because of their importance in PQ metering. The authors’ intention is to show not the novelty of the algorithms but rather the rapid implementation issues.</p><sec id="Sec2"><title>Rapid prototyping</title><sec id="Sec3"><title>Rapid prototyping approach</title><p id="Par20">The main advantage of the rapid prototyping approach is the ability to focus on the problem while omitting the details of its implementation. Development is carried out in an environment that offers a high level of abstraction, and the implementation on a hardware platform is performed by automatically generated code in the target programming language. The differences with respect to the classical software development process can be shown using the example of a filter design. The classical approach requires the selection of the filter structure, the calculation of parameters, and, finally, the implementation of the filter in a programming language. The rapid prototyping path is reduced to giving the type and parameters of the filter bandwidth. The source code of the filter procedures is then generated automatically. This approach results in ability to rapidly test and verify the proposed strategy while at the same time reducing the number of programming errors.</p><p id="Par21">The MATLAB/Simulink stages of design and implementation of a measurement algorithm are shown in Figure <xref rid="Fig1" ref-type="fig">1</xref>. A data processing algorithm is developed as a Simulink diagram and then excited by test data vectors until the results are compliant with the reference results. At this point in the process, the design consists entirely of simulations without any references to the hardware on which the designed algorithm is intended to run.<fig id="Fig1"><label>Figure 1</label><caption xml:lang="en"><p><bold>Stages of rapid prototyping approach.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig1_HTML.gif" id="MO1"/></fig></p><p id="Par22">The implementation on target hardware requires the replacement of simulation inputs and outputs by real signals. The interface can be established by controlling A/D and D/A converters, using files or databases, or over standard communication protocols such as Modbus, OPC Data Access, or OPC Unified Architecture. Modern processors map the A/Ds and D/As as memory, and communication protocol buffers also are allocated in memory, hence, without loss of generality, it can be assumed that in each case, communication is performed by reading and writing to memory locations. To switch from simulation to execution by a microprocessor, only the simulated inputs and outputs need to be swapped for memory access blocks.</p><p id="Par23">At this stage, the C code can be automatically generated. The <italic>MATLAB Coder</italic> [<xref ref-type="bibr" rid="CR18">18</xref>] and <italic>Simulink Coder</italic> [<xref ref-type="bibr" rid="CR19">19</xref>] packages are required to translate a Simulink diagram into equivalent C procedures. The generated code contains three sets of procedures: initialisation procedures executed once when the calculations begin, solver procedures that calculate the model at each sampling period, and termination procedures. Usually, the metering algorithms do not have a specific operating time, so the termination procedures are never called.</p><p id="Par24">The generated code is functionally equivalent to the Simulink diagram. The solver procedures read data from the defined memory location, carry out the calculations, and store the results to the given memory addresses. In the case of a PQ metering application, the Simulink diagrams implement calculations for root mean square values (RMS), spectrum, asymmetry, and flicker, resulting in the automatic generation of a PQ measurement library.</p><p id="Par25">The C procedures, generated from Simulink diagrams, are used to create tasks in a real-time operating system (RTOS). The data comes directly from A/D converters with a sampling frequency of 10.24 kHz. The A/Ds measure phase voltages and line currents, and the A/D results are stored in First In-First Out (FIFO) queues that trigger the execution of the tasks. The FIFO is a buffer where samples are stored until the following tasks become ready for execution, synchronizing the data source to the data consumer, and preventing any measurement points from being lost. The tasks read voltages and currents by accessing the FIFO memory and perform calculations for every incoming data sample. Inter-task communication is performed over memory locations, as was defined in the Simulink diagrams.</p><p id="Par26">An alternative to the C-code generation path, the HDL Coder [<xref ref-type="bibr" rid="CR20">20</xref>] package converts Simulink diagrams into Verilog or VHDL descriptions (see [<xref ref-type="bibr" rid="CR16">16</xref>] and [<xref ref-type="bibr" rid="CR17">17</xref>] as examples). HDL code is synthesizable and can be implemented as an FPGA module. However, unlike C-code procedures, HDL modules may not perform floating point calculations, and the algorithms must be converted into a fixed-point representation. The <italic>Fixed-Point Designer</italic> [<xref ref-type="bibr" rid="CR21">21</xref>] toolbox supports this conversion, however, the conversion is usually time-consuming and sometimes may not even be possible.</p></sec><sec id="Sec4"><title>Hardware platform</title><p id="Par28">The Mars Starter Kit evaluation board from Enclustra was selected as the test hardware platform [<xref ref-type="bibr" rid="CR22">22</xref>]. The board contains Zynq integrated circuits from Xilinx. The Zynq units contain within the single integrated circuit a dual-core ARM Cortex A9 processor equipped with the double precision floating point extension, reconfigurable FPGA fabric equipped with gates, registers, and RAM resources as well as communication cores (see Figure <xref rid="Fig2" ref-type="fig">2</xref>). An external A/D converter board is connected to measure grid voltages and currents. The board is equipped with Analog Devices AD7980 1MSPS, 16-bit, successive approximation analogue-to-digital converters. The A/Ds are controlled by an IP (intellectual property) core implemented in the FPGA. The core is developed in the VHDL language and operates as a component of the FPGA, as a kind of simple coprocessor. The A/D converters require the sequence of control signals to be generated with accuracy on the order of a few dozen of nanoseconds. Such accuracy cannot be achieved in programming, and has to be implemented as a silicon circuit.<fig id="Fig2"><label>Figure 2</label><caption xml:lang="en"><p><bold>Zynq hardware platform.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig2_HTML.gif" id="MO2"/></fig></p><p id="Par29">One ARM processor runs the FreeRTOS real-time operating kernel. FreeRTOS tasks are created directly from the code generated automatically from Simulink diagrams. The second ARM processor runs a Linux distribution and is responsible mainly for implementing communication with the device via Ethernet.</p><p id="Par30">The laboratory prototype of the flickermeter is shown in Figure <xref rid="Fig3" ref-type="fig">3</xref>. It consists of two boards—one equipped with the Zynq, memory, interfaces, and connectors to the communication channels. The second one operates as an interface to the analogue inputs.<fig id="Fig3"><label>Figure 3</label><caption xml:lang="en"><p><bold>Laboratory flickermeter prototype.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig3_HTML.gif" id="MO3"/></fig></p><p id="Par31">The prototype has compact dimensions, but also has enough computational power to implement the chosen measurement algorithms. The worst case CPU utilisation of the ARM 1 processor is 7% when running the synchronisation and flicker calculation algorithms. The average ARM 2 utilisation is 5% when running the Modbus/TCP server in the Linux environment.</p></sec></sec><sec id="Sec5"><title>Case studies</title><sec id="Sec6"><title>Synchronization with line voltage</title><p id="Par34">A significant part of the PQ metering process is synchronisation with the line voltage. The PQ metering standards, namely EN 61000-4-30 and EN 61000-4-7, define strict requirements in this area. In particular, all quantities should be measured within 10 cycle intervals for 50 Hz systems (for 60 Hz systems 12 cycles are required). In addition, RMS measurements for event detection and flicker reference values must be measured by means of a sliding one cycle interval that moves in half-cycle steps. Consequently, correct detection of a cycle is crucial. A typical phase locked loop (PLL) could be used for this task; however, it can be prone to voltage disturbances (e.g. harmonic distortion) or events (e.g. voltage dips). For three phase systems, the asymmetry could also affect a typical PLL system. Therefore, a robust implementation of the PLL is an important task in order to make a PQ meter operate correctly.</p><p id="Par35">The PLL technique is a subject of great interest, and many PLL architectures and applications have been presented (e.g. [<xref ref-type="bibr" rid="CR23">23</xref>-<xref ref-type="bibr" rid="CR26">26</xref>]). The Enhanced PLL (EPLL) contains an adaptive notch filter and provides a higher degree of insensitivity to variable-frequency input signals. A detailed description of the EPLL structure is given in [<xref ref-type="bibr" rid="CR23">23</xref>,<xref ref-type="bibr" rid="CR27">27</xref>-<xref ref-type="bibr" rid="CR29">29</xref>]. This structure has been selected to demonstrate the proposed rapid implementation method.</p><p id="Par36">Figure <xref rid="Fig4" ref-type="fig">4</xref> presents the Simulink diagram of the EPLL. The <italic>Reference sin generator</italic> block is the source of test data (see Figure <xref rid="Fig1" ref-type="fig">1</xref>). The <italic>RefSin</italic> output generates the sine wave for which amplitude, phase, and frequency are disturbed. The output of the EPLL is a sine signal denoted as <italic>u(t)</italic>. The EPLL also outputs the detected amplitude, frequency, and phase, marked respectively as <italic>A(t)</italic>, <italic>w0(t),</italic> and <italic>phase(t)</italic>. The <italic>Compare</italic> scope acquires the simulation results and is used to compare the response of the EPLL to the reference signals.<fig id="Fig4"><label>Figure 4</label><caption xml:lang="en"><p><bold>EPLL - simulation diagram.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig4_HTML.gif" id="MO4"/></fig></p><p id="Par37">The <italic>Hit Crossing</italic> block detects the zero crossing points of the sine signal generated by the EPLL. It is used for synchronising the PQ measurement algorithms to the power signal. Correct detection of the amplitude, frequency, and phase by the EPLL indicate the synchronous operation of the loop. The difference between the reference sine signal <italic>uref(t)</italic> and the EPLL output <italic>u(t)</italic> is used to tune the loop. However, only the zero crossing signal is used for the measurement algorithms.</p><p id="Par38">The EPLL tuning requires calculation of the <italic>u1</italic>, <italic>u2,</italic> and <italic>u3</italic> gains (see Figure <xref rid="Fig4" ref-type="fig">4</xref>). The parameter values were determined by numerical optimization of the loop response to the test excitation. The response to a step change in amplitude, frequency, and phase was tested. The following cost sub-functions were applied:<disp-formula id="Equa"><alternatives><mml:math id="Equa_Math"><mml:mi>J</mml:mi><mml:mo>=</mml:mo><mml:mfenced close="]" open="["><mml:mtable columnalign="center"><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msqrt><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo stretchy="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:mi>u</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo>−</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:msqrt></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msqrt><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo stretchy="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:mi>A</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo>−</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:msqrt></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:mtable columnalign="center"><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msqrt><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo stretchy="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:mi>w</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo>−</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:msqrt></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msqrt><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo stretchy="true">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:mi mathvariant="normal">phase</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo>−</mml:mo><mml:msub><mml:mi mathvariant="normal">phase</mml:mi><mml:mrow><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="("><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:msqrt></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:math><tex-math id="Equa_TeX">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym}
				\usepackage{amsfonts}
				\usepackage{amssymb}
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ J=\left[\begin{array}{c}\hfill \sqrt{{\displaystyle {\sum}_{i=0}^{N-1}{\left(u\left(i{T}_0\right)-{u}_{\mathrm{ref}}\left(i{T}_0\right)\right)}^2}}\hfill \\ {}\hfill \sqrt{{\displaystyle {\sum}_{i=0}^{N-1}{\left(A\left(i{T}_0\right)-{A}_{\mathrm{ref}}\left(i{T}_0\right)\right)}^2}}\hfill \\ {}\hfill \begin{array}{c}\hfill \sqrt{{\displaystyle {\sum}_{i=0}^{N-1}{\left(w\left(i{T}_0\right)-{w}_{\mathrm{ref}}\left(i{T}_0\right)\right)}^2}}\hfill \\ {}\hfill \sqrt{{\displaystyle {\sum}_{i=0}^{N-1}{\left(\mathrm{phase}\left(i{T}_0\right)-{\mathrm{phase}}_{\mathrm{ref}}\left(i{T}_0\right)\right)}^2}}\hfill \end{array}\hfill \end{array}\right] $$\end{document}</tex-math><graphic specific-use="web" mime-subtype="GIF" xlink:href="13634_2015_192_Article_Equa.gif"/></alternatives></disp-formula></p><p id="Par39">where <italic>T</italic><sub><italic>0</italic></sub> is the sampling period, <italic>u</italic><sub><italic>ref</italic></sub> and <italic>u</italic> are respectively input and output sine signals of the loop, <italic>A</italic><sub><italic>ref</italic></sub> and <italic>A</italic> are respectively reference and measured amplitudes, <italic>w</italic><sub><italic>ref</italic></sub> and <italic>w</italic> are respectively reference and measured pulsation values, <italic>phase</italic><sub><italic>ref</italic></sub> and <italic>phase</italic> are respectively reference and measured phase values, and <italic>N</italic> is the number of samples during the numerical optimisation experiment. The sampling frequency was set to 10.24 kHz. The optimisation procedure can be defined as:<disp-formula id="Equb"><alternatives><mml:math id="Equb_Math"><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi mathvariant="normal">opt</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi mathvariant="normal">opt</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mn>3</mml:mn><mml:mi mathvariant="normal">opt</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:munder><mml:mo>min</mml:mo><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:munder><mml:mi>W</mml:mi><mml:mo>*</mml:mo><mml:mi>J</mml:mi></mml:math><tex-math id="Equb_TeX">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym}
				\usepackage{amsfonts}
				\usepackage{amssymb}
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \left[{u}_{1\mathrm{opt}},{u}_{2\mathrm{opt}},{u}_{3\mathrm{opt}}\right]=\underset{u_1,{u}_2,{u}_3}{ \min }W*J $$\end{document}</tex-math><graphic specific-use="web" mime-subtype="GIF" xlink:href="13634_2015_192_Article_Equb.gif"/></alternatives></disp-formula></p><p id="Par40">where <italic>W</italic> is a four element row vector of non-negative constants. The optimisation is performed in the MATLAB environment by calling the <italic>fminsearch</italic> function [<xref ref-type="bibr" rid="CR30">30</xref>].</p><p id="Par41">The selection of the <italic>W</italic> vector elements determines the optimal <italic>u</italic><sub>1opt</sub>, <italic>u</italic><sub>2opt</sub> and <italic>u</italic><sub>3opt</sub> values and finally the behaviour of the EPLL. For the flicker measurement, the EPLL is used to synchronise the algorithm to the grid signal when the loop output signal <italic>u</italic>(<italic>iT</italic><sub>0</sub>) follows the input signal <italic>u</italic><sub>ref</sub>(<italic>iT</italic><sub>0</sub>). The optimal loop parameters are calculated for <italic>W</italic> such that only the first element is a non-negative value and the remaining elements are set to zero. During the optimisation, the reference sine signal is disturbed by step phase, frequency, and amplitude changes. The calculated optimal values are:<disp-formula id="Equc"><alternatives><mml:math id="Equc_Math"><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi mathvariant="normal">opt</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi mathvariant="normal">opt</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mn>3</mml:mn><mml:mi mathvariant="normal">opt</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced close="]" open="["><mml:mrow><mml:mn>3</mml:mn><mml:mspace width="0.3em"/><mml:mn>919.07</mml:mn><mml:mo>,</mml:mo><mml:mspace width="0.5em"/><mml:mn>147.7206</mml:mn><mml:mo>,</mml:mo><mml:mspace width="0.5em"/><mml:mn>208.1230</mml:mn></mml:mrow></mml:mfenced></mml:math><tex-math id="Equc_TeX">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym}
				\usepackage{amsfonts}
				\usepackage{amssymb}
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \left[{u}_{1\mathrm{opt}},{u}_{2\mathrm{opt}},{u}_{3\mathrm{opt}}\right]=\left[3\kern0.3em 919.07,\kern0.5em 147.7206,\kern0.5em 208.1230\right] $$\end{document}</tex-math><graphic specific-use="web" mime-subtype="GIF" xlink:href="13634_2015_192_Article_Equc.gif"/></alternatives></disp-formula></p><p id="Par42">For test purposes, the optimised loop is applied not to the simulated signal but to synchronise to the real grid signal measured in the university power laboratory. The total harmonic distortion (THD) of the signal is 2.95% and, additionally, the signal is disturbed by a − <italic>π</italic>/<italic>6</italic> rad step phase change, 5% frequency step, and 30% amplitude sag. The disturbances of the phase, frequency, and amplitude appear respectively at 60, 120, and 180 ms. The results are shown in Figure <xref rid="Fig5" ref-type="fig">5</xref>. The upper diagram presents input test signal <italic>u</italic><sub><italic>ref</italic></sub> and the sinusoidal response of loop <italic>u</italic>. The bottom left picture shows the difference between <italic>u</italic><sub><italic>ref</italic></sub> and <italic>u</italic>. The time period between the moments when the <italic>u</italic><sub><italic>ref</italic></sub> and <italic>u</italic> signals cross the zero voltage level is given in the bottom right diagram.<fig id="Fig5"><label>Figure 5</label><caption xml:lang="en"><p><bold>EPLL synchronisation to a real signal.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig5_HTML.gif" id="MO5"/></fig></p><p id="Par43">The miscellaneous sets of vector W values enable us to switch the EPLL into amplitude, frequency, or phase measurement modes and exemplify the flexibility of the proposed approach.</p><p id="Par44">After simulation and optimisation phases, the test signal sources are replaced by memory access drivers. The updated diagram is given in Figure <xref rid="Fig6" ref-type="fig">6</xref>. The input driver <italic>Ua</italic> and the output drivers <italic>Cross zero</italic>, <italic>EPLL sin</italic>, <italic>Amplitude</italic>, <italic>Omega,</italic> and <italic>Phase</italic> are created as Simulink level-2 C-code S-functions [<xref ref-type="bibr" rid="CR31">31</xref>]. The S-functions access memory buffers and operate as interfaces between the Simulink blocks and to the remaining flickermeter blocks.<fig id="Fig6"><label>Figure 6</label><caption xml:lang="en"><p><bold>EPLL - diagram prepared for code generation.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig6_HTML.gif" id="MO6"/></fig></p><p id="Par45">The diagram is used to automatically generate code. The generation procedures call the input S-function to read the input signal from the memory hexadecimal address FCA0000, run the EPLL algorithm, and call the output S-functions to store the results to memory locations from EA000000 to EA000010. When running the generated software in real time, it is essential that the execution takes place with the same sampling period as during code generation.</p><p id="Par46">The steps presented during the EPLL implementation can be applied to other algorithms. The next section presents the rapid development path of the flicker measurement algorithm. However this approach can also be applied to the development of the remaining PQ algorithms, and even to the development of control strategies.</p></sec><sec id="Sec7"><title>Flicker implementation</title><p id="Par48">A nontrivial example of rapid prototyping and implementation of a metering problem is the flickermeter. Light flicker measurement and the flickermeter are described in detail in standard EN 61000-4-15. Basically, the meter consists of several blocks (see Figure <xref rid="Fig7" ref-type="fig">7</xref>(a)).<fig id="Fig7"><label>Figure 7</label><caption xml:lang="en"><p><bold>Block diagram and its Simulink model for instantaneous flicker computation.</bold> Block diagram of the IEC flickermeter according to the standard EN 61000-4-15 <bold>(a)</bold> and its sample model for instantaneous flicker computation in MATLAB/Simulink <bold>(b)</bold>.</p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig7_HTML.gif" id="MO7"/></fig></p><p id="Par49">The flickermeter is described in the standard as an analogue device, i.e. all signal processing blocks are defined in the analogue domain. The reason for this is that at the time of the standard creation, the flickermeter was intended to be single device built using standard electronic parts. Nowadays, the flicker severity measurement is a function of a digital meter (PQ analyser) but the algorithms for computing short-term flicker P<sub>ST</sub> and long-term flicker P<sub>LT</sub> must follow the description in the standard. In state-of-the-art devices, all the operations on the input signal are done in the digital domain. Consequently, the problem of implementing a flickermeter in a digital processor requires discretisation of the analogue blocks and implementation of the discrete transfer functions. The considered blocks are (see Figure <xref rid="Fig7" ref-type="fig">7</xref>(a)):<list list-type="order"><list-item><p id="Par50">Input gain control block: in the standard, the block operates as a voltage adaptor and signal conditioning unit and provides initial scaling. In the digital model, the block provides only the scaling, which is done by dividing the input signal by the reference signal. The reference signal is the half-period RMS value processed by the first order digital filter with a 27.3 s time constant (as defined in the standard). The filter has to be designed and implemented in the digital domain.</p></list-item><list-item><p id="Par51">Square multiplier block: the squaring operation resembles the behaviour of an incandescent lamp. The block, together with the high pass filter from the next block, operates as a demodulator. A digital implementation of this algorithm is straightforward.</p></list-item><list-item><p id="Par52">High pass filter and the weighting filter: the blocks consist of three filters. The first high pass filter eliminates the DC component of the voltage, and the standard suggests a first order filter with a −3 dB at 0.05 Hz cut-off frequency. The second filter is a low pass one, and the standard requires a sixth order Butterworth filter with a −3 dB at 35 Hz cut-off frequency (for 230 V systems). A digital implementation of the filter requires utilisation of filter design tools in order to evaluate the parameters of the filter. The last filter is the co-called weighting filter. It simulates the spectral properties of the human visual system. The filter is described as a Laplace transfer function model:<disp-formula id="Equd"><alternatives><mml:math id="Equd_Math"><mml:mi>G</mml:mi><mml:mfenced close=")" open="("><mml:mi>s</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>k</mml:mi><mml:msub><mml:mi>ω</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>λ</mml:mi><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:msubsup><mml:mi>ω</mml:mi><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>.</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="true">/</mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mfenced close=")" open="("><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="true">/</mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mfenced close=")" open="("><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="true">/</mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac></mml:math><tex-math id="Equd_TeX">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym}
				\usepackage{amsfonts}
				\usepackage{amssymb}
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ G(s)=\frac{k{\omega}_1s}{s^2+2\lambda s+{\omega}_1^2}.\frac{1+s/{\omega}_2}{\left(1+s/{\omega}_3\right)\left(1+s/{\omega}_4\right)} $$\end{document}</tex-math><graphic specific-use="web" mime-subtype="GIF" xlink:href="13634_2015_192_Article_Equd.gif"/></alternatives></disp-formula></p><p id="Par53">where the parameters <italic>k</italic>, λ, and ω<sub><italic>i</italic></sub> (<italic>i</italic> = 1…4) are described in the standard and are different for 230 V and 110 V systems. Therefore the first operation is to obtain the discrete transfer function so the frequency response of the analogue filter and the discrete implementation are similar in the frequency domain.</p></list-item></list><list list-type="order"><list-item><p id="Par54">Squaring and smoothing: this block performs two functions, it simulates the eye-brain perception by means of a squaring operation and emulates the memory effect of the brain. The effects can be implemented as the sliding mean operator, however the standard suggests the utilisation of a first order filter with a 300 ms time constant. The output of this block is instantaneous flicker <italic>P</italic><sub>inst</sub>.</p></list-item><list-item><p id="Par55">Statistical analysis: this is the only block that utilises digital data processing to obtain its output: <italic>P</italic><sub>ST</sub> and <italic>P</italic><sub>LT</sub> flicker levels. The computation is based on the percentiles computation and calculates the flicker according to the formula:<disp-formula id="Eque"><alternatives><mml:math id="Eque_Math"><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mn>0.0314</mml:mn><mml:msub><mml:mi>P</mml:mi><mml:mn>0.1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>0.0525</mml:mn><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>0.0657</mml:mn><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>3</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>0.28</mml:mn><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>10</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>0.08</mml:mn><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>50</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msqrt></mml:math><tex-math id="Eque_TeX">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym}
				\usepackage{amsfonts}
				\usepackage{amssymb}
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {P}_{\mathrm{ST}}=\sqrt{0.0314{P}_{0.1}+0.0525{P}_{1s}+0.0657{P}_{3s}+0.28{P}_{10s}+0.08{P}_{50s}} $$\end{document}</tex-math><graphic specific-use="web" mime-subtype="GIF" xlink:href="13634_2015_192_Article_Eque.gif"/></alternatives></disp-formula></p><p id="Par56">where:<disp-formula id="Equf"><alternatives><mml:math id="Equf_Math"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>50</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>30</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>50</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>80</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo stretchy="true">/</mml:mo><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>10</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>6</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>8</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>10</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>13</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>17</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo stretchy="true">/</mml:mo><mml:mn>5</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>3</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2.2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo stretchy="true">/</mml:mo><mml:mn>3</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>0.7</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mn>1.5</mml:mn></mml:msub></mml:mrow></mml:mfenced><mml:mo stretchy="true">/</mml:mo><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math><tex-math id="Equf_TeX">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym}
				\usepackage{amsfonts}
				\usepackage{amssymb}
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \begin{array}{l}{P}_{50s}=\left({P}_{30}+{P}_{50}+{P}_{80}\right)/3\\ {}{P}_{10s}=\left({P}_6+{P}_8+{P}_{10}+{P}_{13}+{P}_{17}\right)/5\\ {}{P}_{3s}=\left({P}_{2.2}+{P}_3+{P}_4\right)/3\\ {}{P}_{1s}=\left({P}_{0.7}+{P}_1+{P}_{1.5}\right)/3\end{array} $$\end{document}</tex-math><graphic specific-use="web" mime-subtype="GIF" xlink:href="13634_2015_192_Article_Equf.gif"/></alternatives></disp-formula></p><p id="Par57">and P<sub><italic>x</italic></sub> is the <italic>x</italic>-th percentile of the values of <italic>P</italic><sub>inst</sub> logged during a specified time interval, where <italic>x</italic> is 0.1, 0.7, 1, 1.5, 2.2, 3, 4, 6, 8, 10, 13, 17, 30, 50, 80. The interval can vary from 1 to 15 m, however, the EN 61000-4-30 standard assumes 10 m for a typical flicker severity evaluation. This conforms with the interval set by EN 61000-4-30 for PQ evaluation. The evaluation of <italic>P</italic><sub>LT</sub> is performed using 12 samples of <italic>P</italic><sub>ST</sub>, hence the long-term flicker describes the flicker severity for the last 2 h. Because the block is actually a discrete implementation in a digital processor, it requires numerical procedures for sorting and mathematical calculation.</p></list-item></list></p><p id="Par58">The MATLAB/Simulink package provides toolboxes and blocksets for both digital and analogue system design and analysis. Therefore, implementation of the flickermeter in MATLAB/Simulink follows the development stages of the rapid development method. The basic structure of the Simulink diagram that implements the signal processing stages is shown in Figure <xref rid="Fig7" ref-type="fig">7</xref>(b). Note that the model closely resembles the description in the standard. Each filter defined by spectral properties is defined in the <italic>z</italic> domain by means of standard tools available in the MATLAB/Simulink package. The weighting filter requires special procedures. In [<xref ref-type="bibr" rid="CR11">11</xref>], the transfer functions of the filters were obtained analytically by defining the filter in the <italic>s</italic> domain and next using a Bilinear Transform to obtain the transfer function in the <italic>z</italic> domain. This procedure does not match the rapid implementation approach. Filter parameters in the flickermeter blocks are strictly defined in the standard, but their selection depends on the voltage level. On the other hand, there are several discretisation methods and the choice can affect the properties of the flickermeter. The discretisation also depends on sample time, which is related to the hardware platform, and therefore can be unspecified at modelling time. Consequently, the best option is to discretise the filter numerically and let the software perform all necessary computations. The MATLAB/Simulink package supports this operation by providing commands for the immediate discretisation of transfer functions. This functionality is used to obtain a fully automatic discretisation of the weighting filter. Therefore, the filter is defined in the <italic>s</italic> domain and then numerically discretised using MATLAB commands.</p><p id="Par59">The validation of the model and recalibration can also be done in the simulation environment. It requires additional blocks for test signal generation. The test signals are strictly defined in the EN 61000-4-15 standard. Figure <xref rid="Fig8" ref-type="fig">8</xref> shows a sample flickermeter validation framework.<fig id="Fig8"><label>Figure 8</label><caption xml:lang="en"><p><bold>The flickermeter model testing framework.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig8_HTML.gif" id="MO8"/></fig></p><p id="Par60">As in the case of the EPLL implementation in the flickermeter diagram, the signals are reconnected to the driver blocks to access the measurements and store the <italic>P</italic><sub>ST</sub> and <italic>P</italic><sub>LT</sub> values. The C code is automatically generated from the Simulink diagram, compiled, and executed in real-time by the Zynq hardware platform.</p></sec><sec id="Sec8"><title>Results of the flicker algorithm</title><p id="Par62">The results of the generated flickermeter are shown in Figure <xref rid="Fig9" ref-type="fig">9</xref>. The diagram presents 24 hours of measurements. The upper diagram presents two <italic>P</italic><sub>ST</sub> values: one generated by the reference class A PQ analyser (A-eberle PQI-D) and the second generated by the test hardware platform described in Section II B. The Zynq test device ran the code generated automatically from the Simulink diagram. The reference PQ meter is a class A meter (according to IEC 61000-4-30) with the metering uncertainty defined by the standard, e.g. for voltage, the uncertainty is ± 0.1% of declared voltage (i.e. the grid’s nominal). Flicker uncertainty is 5% and is defined by IEC 61000-4-15. For the test device, the metering was done by means of voltage transducers of type LV 25-P [<xref ref-type="bibr" rid="CR32">32</xref>]. According to the data sheet, the overall accuracy of the transducers is 0.9% of the voltage range, which is 400 V in this case.<fig id="Fig9"><label>Figure 9</label><caption xml:lang="en"><p><bold>The flickermeter results.</bold></p></caption><graphic specific-use="web" mime-subtype="GIF" xlink:href="MediaObjects/13634_2015_192_Fig9_HTML.gif" id="MO9"/></fig></p><p id="Par63">The meters were arranged in the PQ metering laboratory in which the building mains was available for metering. The meters were connected to the same voltage signals so the comparison refers to the real metering situation.</p><p id="Par64">The lower diagram presents the difference between the data series. The difference can be explained by the accuracy of the sensors. For the hardware platform, typical off-shelf transducers were used with a conditional board not designed for precise measurements. On the other hand, the typical error allowed in the standard for <italic>P</italic><sub>ST</sub> is 5% when <italic>P</italic><sub>ST</sub> = 1.</p></sec></sec></sec><sec id="Sec9" sec-type="conclusion"><title>Conclusions</title><p id="Par65">This article presented a method of rapid code generation for implementing and testing of PQ algorithms. The method covers not only the PQ meter development, but also the preparation of the certification tests and procedures. The MBD approach shortens the time from an idea to an operating device. A user is supported by the functions of a CAE package, can focus on the problem itself, and skip the laborious implementation details of the algorithms under development. In the presented case, Simulink was used as the CAE platform. The efficiency of the presented development path becomes apparent in the implementation of the flicker calculation algorithm. The flickermeter channel consists of a series of filters and data processing blocks. It was first developed and validated in simulation, the C code was then generated and implemented on a real hardware platform. The correctness of the implemented algorithm was confirmed by the match of the generated flicker values with the results of the commercial reference metering device.</p><p id="Par66">PQ measurements have recently become an important topic that has resulted in different regulatory documents. An example is the differences between the EN 50160 standard for supply quality and national regulations. The standard requires e.g. RMS voltage within ± 10% limits in relation to the nominal (or declared) value for low voltage networks. However, in some countries, the limits are different, e.g. in France, the admissible change is from −10% to +6%, and in Spain, it is ± 7%. In addition, the statistical measure differs: the standard requires computation of the 95 and 100 percentiles. The grid codes in Poland for a transmission system require a 99 percentile for flicker and voltage distortion when a wind farm connection is considered. There are also parameters not required in the standard but required in the grid codes, e.g. the THFF (telephone harmonic form factor). The metering interval is also subject to change, e.g. in Norway, a 1 minute interval is used. On the other hand, there is the possibility of change of the limit values, percentile, or even metering interval in the future. This requires additional work in the software of a PQ meter to make the change possible. The real problem arises when non-standard algorithms are required, e.g. the localization of a PQ disturbance source. This functionality is very useful when the introduction of PQ contracts is considered. However, the existing algorithms are not ready for implementation because of lack of efficiency.</p><p id="Par67">The ability to easily add a new algorithm with new functionality to a PQ meter is clearly necessary. Rapid prototyping and implementation makes it possible to test the algorithm and produce the code without manual implementation.</p><p id="Par68">This study highlights the need for a flexible and rapid development method for devices to meet the as yet non-existing standards. The presented approach is a step towards satisfying these demands.</p></sec></body><back><ack><title>Acknowledgements</title><p>This work was supported by the AGH University of Science and Technology under European Regional Development Found, Subsidy no POiG.01.03.01-30-056/12 and by the AGH University of Science and Technology KIC-ASS Grant no 7.7.120.7037.</p></ack><ref-list id="Bib1"><title>References</title><ref-list><ref id="CR1"><label>1.</label><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bollen</surname><given-names>MHJ</given-names></name><name><surname>Gu</surname><given-names>IYH</given-names></name></person-group><source>Signal processing of power quality disturbances</source><year>2006</year><publisher-loc>New York, NY, USA</publisher-loc><publisher-name>IEEE Press</publisher-name><pub-id pub-id-type="doi">10.1002/0471931314</pub-id></mixed-citation></ref><ref id="CR2"><label>2.</label><mixed-citation publication-type="other">A Zobaa, MM Canteli, R Bansal (eds.), <italic>Application of Signal Processing in Power Quality Monitoring</italic>, in <italic>Power Quality Monitoring, Analysis and Enhancement</italic>) (InTechOpen, 2012). doi:10.5772/21492</mixed-citation></ref><ref id="CR3"><label>3.</label><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Dell'Aquila</surname><given-names>RV</given-names></name><name><surname>Balboni</surname><given-names>L</given-names></name><name><surname>Morici</surname><given-names>R</given-names></name></person-group><source>A new approach: modeling, simulation, development and implementation of a commercial grid-connected transformerless PV inverter, SPEEDAM International Symposium on Power Electronics, Electrical Drives, Automation and Motion, 1422–1429</source><year>2010</year><comment>doi:10.1109/SPEEDAM.2010.5542040</comment></mixed-citation></ref><ref id="CR4"><label>4.</label><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>X</given-names></name><name><surname>Kirby</surname><given-names>B</given-names></name><name><surname>Zhao</surname><given-names>Q</given-names></name><name><surname>Ma</surname><given-names>Y</given-names></name><name><surname>Xu</surname><given-names>F</given-names></name></person-group><source>Model-based design process for product development of substation IEDs, 2nd IEEE International Conference &amp; Exhibition (ENERGYCON)</source><year>2012</year><fpage>968</fpage><lpage>974</lpage><comment>doi:10.1109/EnergyCon.2012.6348290</comment></mixed-citation></ref><ref id="CR5"><label>5.</label><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Adam</surname><given-names>G</given-names></name><name><surname>Zbanţ</surname><given-names>A</given-names></name><name><surname>Livint</surname><given-names>G</given-names></name></person-group><source>New Simulink control block for single phase shunt active power filters, 8th International Symposium on Advanced Topics in Electrical Engineering (ATEE)</source><year>2013</year><fpage>1</fpage><lpage>4</lpage><comment>doi:10.1109/ATEE.2013.6563485</comment></mixed-citation></ref><ref id="CR6"><label>6.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kirubakaran</surname><given-names>A</given-names></name><name><surname>Jain</surname><given-names>S</given-names></name><name><surname>Nema</surname><given-names>RK</given-names></name></person-group><article-title xml:lang="en">DSP-controlled power electronic interface for fuel-cell-based distributed generation</article-title><source>IEEE Trans. Power Electron.</source><year>2011</year><volume>26</volume><issue>12</issue><fpage>3853</fpage><lpage>3864</lpage><pub-id pub-id-type="doi">10.1109/TPEL.2011.2138162</pub-id><comment>doi:10.1109/TPEL.2011.2138162</comment></mixed-citation></ref><ref id="CR7"><label>7.</label><mixed-citation publication-type="other">K Vardar, T Sürgevil, E Akpinar, <italic>Rapid prototyping applications on three-phase PWM rectifier and shunt active power filter</italic>. (International Conference on Electrical and Electronics Engineering, 2009), p. 258–262</mixed-citation></ref><ref id="CR8"><label>8.</label><mixed-citation publication-type="other">P Meena, KU Rao, D Ravishankar, <italic>Real-time detection and analysis of PQ disturbances with DSP using MATLAB embedded link to code composer studio</italic>. (Third International Conference on Power Systems, 2009), p. 1–5. doi:10.1109/ICPWS.2009.5442725</mixed-citation></ref><ref id="CR9"><label>9.</label><mixed-citation publication-type="other">K Kołek, K Piątek, P Włodarczyk, Rapid algorithm prototyping for SCADA applications, (Advances in Electrical and Computer Engineering, in press)</mixed-citation></ref><ref id="CR10"><label>10.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>McGranaghan</surname><given-names>MF</given-names></name><name><surname>Santoso</surname><given-names>S</given-names></name></person-group><article-title xml:lang="en">Challenges and trends in analyses of electric power quality measurement data</article-title><source>EURASIP J. Adv. Signal Process</source><year>2007</year><volume>57985</volume><fpage>1</fpage><lpage>6</lpage><comment>doi:10.1155/2007/57985</comment></mixed-citation></ref><ref id="CR11"><label>11.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>White</surname><given-names>LW</given-names></name><name><surname>Bhattacharya</surname><given-names>S</given-names></name><name><surname>Discrete</surname><given-names>A</given-names></name></person-group><article-title xml:lang="en">MATLAB-Simulink flickermeter model for power quality studies</article-title><source>IEEE Trans. Instrum. Meas.</source><year>2010</year><volume>59</volume><issue>3</issue><fpage>527</fpage><lpage>533</lpage><pub-id pub-id-type="doi">10.1109/TIM.2009.2023121</pub-id><comment>doi:10.1109/TIM.2009.2023121</comment></mixed-citation></ref><ref id="CR12"><label>12.</label><mixed-citation publication-type="other">MI Milanes, V Minambres, E Romero, F Barrero, <italic>Quality meter of electric power systems based on IEEE standard 1459-2000</italic>. (Compatibility and Power Electronics, 2009), p. 86–92. doi:10.1109/CPE.2009.5156018</mixed-citation></ref><ref id="CR13"><label>13.</label><mixed-citation publication-type="other">M Rogóż, Z Hanzelka, <italic>The design and construction of a power quality parameters recorder</italic>. 9th International Conference. (Electrical Power Quality and Utilisation, 2007), p. 1–6. doi:10.1109/EPQU.2007.4424150</mixed-citation></ref><ref id="CR14"><label>14.</label><mixed-citation publication-type="other">J Krizan, L Ertl, M Bradac, M Jasansky, A Andreev, <italic>Automatic code generation from MATLAB/Simulink for critical applications</italic>. (IEEE 27th Canadian Conference on Electrical and Computer Engineering (CCECE), 2014), p. 1–6. doi:10.1109/CCECE.2014.6901058</mixed-citation></ref><ref id="CR15"><label>15.</label><mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Schwarz</surname><given-names>MH</given-names></name><name><surname>Sheng</surname><given-names>H</given-names></name><name><surname>Sheleh</surname><given-names>A</given-names></name><name><surname>Boercsoek</surname><given-names>J</given-names></name></person-group><source>IEEE/ACS International Conference on Computer Systems and Applications, 1058 – 1063 (2008)</source><year>2008</year><fpage>1058</fpage><lpage>1063</lpage><comment>doi:10.1109/AICCSA.2008.4493678</comment></mixed-citation></ref><ref id="CR16"><label>16.</label><mixed-citation publication-type="other">ET Mekonnen, J Katcha, K Parker, <italic>An FPGA-based digital control development method for power electronics</italic>. (IECON 38th Annual Conference on IEEE Industrial Electronics Society, 2012), p. 222–226. doi:10.1109/IECON.2012.6388804</mixed-citation></ref><ref id="CR17"><label>17.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Selvamuthukumaran</surname><given-names>R</given-names></name><name><surname>Gupta</surname><given-names>R</given-names></name></person-group><article-title xml:lang="en">Rapid prototyping of power electronics converters for photovoltaic system application using Xilinx System Generator</article-title><source>IET Power Electron.</source><year>2014</year><volume>7</volume><issue>9</issue><fpage>2269</fpage><lpage>2278</lpage><pub-id pub-id-type="doi">10.1049/iet-pel.2013.0736</pub-id><comment>doi:10.1049/iet-pel.2013.0736</comment></mixed-citation></ref><ref id="CR18"><label>18.</label><mixed-citation publication-type="other">MATLAB Coder. User's guide, <ext-link xlink:href="http://www.mathworks.com/help/pdf_doc/coder/coder_ug.pdf" ext-link-type="uri">http://www.mathworks.com/help/pdf_doc/coder/coder_ug.pdf</ext-link>. Accessed 5 December 2014</mixed-citation></ref><ref id="CR19"><label>19.</label><mixed-citation publication-type="other">Simulink Coder. User's guide, <ext-link xlink:href="http://www.mathworks.com/help/pdf_doc/rtw/rtw_ug.pdf" ext-link-type="uri">http://www.mathworks.com/help/pdf_doc/rtw/rtw_ug.pdf</ext-link>. Accessed 5 December 2014</mixed-citation></ref><ref id="CR20"><label>20.</label><mixed-citation publication-type="other">HDL coder, <ext-link xlink:href="http://www.mathworks.com/products/hdl-coder/" ext-link-type="uri">http://www.mathworks.com/products/hdl-coder/</ext-link>. Accessed 5 December 2014.</mixed-citation></ref><ref id="CR21"><label>21.</label><mixed-citation publication-type="other">Fixed-point designer. User's guide, <ext-link xlink:href="http://www.mathworks.com/help/releases/R2014b/pdf_doc/fixedpoint/FPTUG.pdf" ext-link-type="uri">http://www.mathworks.com/help/releases/R2014b/pdf_doc/fixedpoint/FPTUG.pdf</ext-link>. Accessed 5 December 2014.</mixed-citation></ref><ref id="CR22"><label>22.</label><mixed-citation publication-type="other">Mars Starter Kits, <ext-link xlink:href="http://www.enclustra.com/en/products/hardware-kits/mars-starter-kits/" ext-link-type="uri">http://www.enclustra.com/en/products/hardware-kits/mars-starter-kits/</ext-link>. Accessed 18 October 2014.</mixed-citation></ref><ref id="CR23"><label>23.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gupta</surname><given-names>A</given-names></name><name><surname>Porippireddi</surname><given-names>A</given-names></name><name><surname>Srinivasa</surname><given-names>VU</given-names></name><name><surname>Sharma</surname><given-names>A</given-names></name><name><surname>Kadam</surname><given-names>M</given-names></name></person-group><article-title xml:lang="en">Comparative study of single phase PLL algorithms for grid synchronization applications</article-title><source>IJECT</source><year>2012</year><volume>3</volume><issue>4</issue><fpage>237</fpage><lpage>245</lpage></mixed-citation></ref><ref id="CR24"><label>24.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shinnaka</surname><given-names>S</given-names></name><name><surname>Robust</surname><given-names>A</given-names></name></person-group><article-title xml:lang="en">Single-phase PLL system with stable and fast tracking</article-title><source>IEEE Trans. Ind. Appl.</source><year>2008</year><volume>44</volume><issue>2</issue><fpage>624</fpage><lpage>633</lpage><pub-id pub-id-type="doi">10.1109/TIA.2008.916750</pub-id><comment>doi:10.1109/TIA.2008.916750</comment></mixed-citation></ref><ref id="CR25"><label>25.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Karimi-Ghartemani</surname><given-names>M</given-names></name><name><surname>Mojiri</surname><given-names>M</given-names></name><name><surname>Safaee</surname><given-names>A</given-names></name><name><surname>Walseth</surname><given-names>JA</given-names></name><name><surname>Khajehoddin</surname><given-names>SA</given-names></name><name><surname>Jain</surname><given-names>P</given-names></name><name><surname>Bakhshai</surname><given-names>A</given-names></name></person-group><article-title xml:lang="en">A new phase-locked loop system for three-phase applications</article-title><source>IEEE Trans. Power Electron.</source><year>2013</year><volume>28</volume><issue>3</issue><fpage>1208</fpage><lpage>1218</lpage><pub-id pub-id-type="doi">10.1109/TPEL.2012.2207967</pub-id><comment>doi:10.1109/TPEL.2012.2207967</comment></mixed-citation></ref><ref id="CR26"><label>26.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guo</surname><given-names>XQ</given-names></name><name><surname>Wy</surname><given-names>W</given-names></name><name><surname>Gu</surname><given-names>HR</given-names></name></person-group><article-title xml:lang="en">Phase locked loop and synchronization methods for grid-interfaced converters: a review</article-title><source>PRZEGLĄD ELEKTROTECHNICZNY (Electric Rev)</source><year>2011</year><volume>87</volume><issue>4</issue><fpage>182</fpage><lpage>187</lpage></mixed-citation></ref><ref id="CR27"><label>27.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Singh</surname><given-names>B</given-names></name><name><surname>Arya</surname><given-names>SR</given-names></name></person-group><article-title xml:lang="en">Implementation of single-phase enhanced phase-locked loop-based control algorithm for three-phase DSTATCOM</article-title><source>IEEE Trans. Power. Deliv.</source><year>2013</year><volume>28</volume><issue>3</issue><fpage>1516</fpage><lpage>1524</lpage><pub-id pub-id-type="doi">10.1109/TPWRD.2013.2257876</pub-id><comment>doi:10.1109/TPWRD.2013.2257876</comment></mixed-citation></ref><ref id="CR28"><label>28.</label><mixed-citation publication-type="other">M Karimi-Ghartemani, JA Walseth, <italic>Using the EPLL algorithm as a preprocessor for fault analysis</italic>. (11th International Conference on Information Science, Signal Processing and their Applications (ISSPA), 2012), p. 1377–1382. doi:10.1109/ISSPA.2012.6310508</mixed-citation></ref><ref id="CR29"><label>29.</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Karimi-Ghartemani</surname><given-names>M</given-names></name><name><surname>Karimi-Ghartemani</surname><given-names>M</given-names></name></person-group><article-title xml:lang="en">Linear and pseudolinear enhanced phased-locked loop (EPLL) structures</article-title><source>IEEE Trans. Ind. Electron.</source><year>2014</year><volume>61</volume><issue>3</issue><fpage>1464</fpage><lpage>1474</lpage><pub-id pub-id-type="doi">10.1109/TIE.2013.2261035</pub-id><comment>doi:10.1109/TIE.2013.2261035</comment></mixed-citation></ref><ref id="CR30"><label>30.</label><mixed-citation publication-type="other">Optimization toolbox user's guide, MathWorks, <ext-link xlink:href="http://www.mathworks.com/help/pdf_doc/optim/optim_tb.pdf" ext-link-type="uri">http://www.mathworks.com/help/pdf_doc/optim/optim_tb.pdf</ext-link>. Accessed 18 October 2014</mixed-citation></ref><ref id="CR31"><label>31.</label><mixed-citation publication-type="other">Simulink. Developing S-functions, MathWorks, <ext-link xlink:href="http://www.mathworks.com/help/pdf_doc/simulink/sfunctions.pdf" ext-link-type="uri">http://www.mathworks.com/help/pdf_doc/simulink/sfunctions.pdf</ext-link>. Accessed 04 December 2014</mixed-citation></ref><ref id="CR32"><label>32.</label><mixed-citation publication-type="other">Voltage Transducer LV 25-P, <ext-link xlink:href="http://www.lem.com/docs/products/lv%2025-p.pdf" ext-link-type="uri">http://www.lem.com/docs/products/lv%2025-p.pdf</ext-link>. Accessed 04 December 2014.</mixed-citation></ref></ref-list></ref-list><notes notes-type="Misc"><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></notes></back></article></records><facets><facet name="subject"><facet-value count="1">Engineering</facet-value><facet-value count="1">Quantum Information Technology, Spintronics</facet-value><facet-value count="1">Signal,Image and Speech Processing</facet-value></facet><facet name="keyword"><facet-value count="1">Automatic code generation</facet-value><facet-value count="1">Flicker</facet-value><facet-value count="1">PLL</facet-value><facet-value count="1">Power quality</facet-value><facet-value count="1">Rapid prototyping</facet-value><facet-value count="1">Simulink</facet-value><facet-value count="1">Synchronisation</facet-value></facet><facet name="pub"><facet-value count="1">EURASIP Journal on Advances in Signal Processing</facet-value></facet><facet name="year"><facet-value count="1">2015</facet-value></facet><facet name="country"><facet-value count="1">Poland</facet-value></facet><facet name="type"><facet-value count="1">Journal</facet-value></facet></facets></response>
